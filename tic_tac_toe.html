<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tic Tac Toe - Min-Max Algorithm</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            margin: 0;
            padding: 20px;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .container {
            background: white;
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            max-width: 800px;
            width: 100%;
        }

        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 30px;
            font-size: 2.5em;
        }

        .game-section {
            display: flex;
            gap: 30px;
            margin-bottom: 30px;
            flex-wrap: wrap;
        }

        .game-board {
            flex: 1;
            min-width: 300px;
        }

        .board {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 5px;
            background: #333;
            padding: 5px;
            border-radius: 10px;
            margin: 20px 0;
        }

        .cell {
            background: white;
            border: none;
            font-size: 2em;
            font-weight: bold;
            height: 80px;
            cursor: pointer;
            border-radius: 5px;
            transition: background-color 0.3s;
        }

        .cell:hover {
            background: #f0f0f0;
        }

        .cell.x {
            color: #e74c3c;
        }

        .cell.o {
            color: #3498db;
        }

        .controls {
            flex: 1;
            min-width: 250px;
        }

        .control-group {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 15px;
        }

        .control-group h3 {
            margin-top: 0;
            color: #333;
        }

        button {
            background: #3498db;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1em;
            margin: 5px;
            transition: background-color 0.3s;
        }

        button:hover {
            background: #2980b9;
        }

        button:disabled {
            background: #bdc3c7;
            cursor: not-allowed;
        }

        .stats {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            margin-top: 20px;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }

        .stat-item {
            background: white;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        .stat-number {
            font-size: 2em;
            font-weight: bold;
            color: #3498db;
        }

        .progress-bar {
            background: #ecf0f1;
            height: 20px;
            border-radius: 10px;
            overflow: hidden;
            margin: 10px 0;
        }

        .progress-fill {
            height: 100%;
            transition: width 0.3s ease;
        }

        .win-rate { background: #27ae60; }
        .lose-rate { background: #e74c3c; }
        .draw-rate { background: #f39c12; }

        .analysis {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 10px;
            padding: 20px;
            margin-top: 20px;
        }

        .game-log {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 15px;
            margin-top: 20px;
            max-height: 200px;
            overflow-y: auto;
        }

        .log-entry {
            padding: 5px 0;
            border-bottom: 1px solid #dee2e6;
            font-family: monospace;
            font-size: 0.9em;
        }

        .status {
            text-align: center;
            font-size: 1.2em;
            font-weight: bold;
            margin: 15px 0;
            padding: 10px;
            border-radius: 5px;
        }

        .status.playing {
            background: #d1ecf1;
            color: #0c5460;
        }

        .status.win {
            background: #d4edda;
            color: #155724;
        }

        .status.lose {
            background: #f8d7da;
            color: #721c24;
        }

        .status.draw {
            background: #fff3cd;
            color: #856404;
        }

        .algorithm-comparison {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-top: 20px;
        }

        .algorithm-stats {
            background: white;
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        @media (max-width: 768px) {
            .game-section {
                flex-direction: column;
            }
            
            .algorithm-comparison {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ® Ø¨Ø§Ø²ÛŒ Tic Tac Toe - Ø§Ù„Ú¯ÙˆØ±ÛŒØªÙ… Min-Max</h1>
        
        <div class="game-section">
            <div class="game-board">
                <div id="status" class="status playing">Ù†ÙˆØ¨Øª Ø´Ù…Ø§ (X)</div>
                <div class="board" id="board">
                    <button class="cell" data-index="0"></button>
                    <button class="cell" data-index="1"></button>
                    <button class="cell" data-index="2"></button>
                    <button class="cell" data-index="3"></button>
                    <button class="cell" data-index="4"></button>
                    <button class="cell" data-index="5"></button>
                    <button class="cell" data-index="6"></button>
                    <button class="cell" data-index="7"></button>
                    <button class="cell" data-index="8"></button>
                </div>
            </div>

            <div class="controls">
                <div class="control-group">
                    <h3>ğŸ¯ ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ø¨Ø§Ø²ÛŒ</h3>
                    <button onclick="resetGame()">ğŸ”„ Ø´Ø±ÙˆØ¹ Ø¨Ø§Ø²ÛŒ Ø¬Ø¯ÛŒØ¯</button>
                    <button onclick="playAutoGame()">ğŸ¤– Ø¨Ø§Ø²ÛŒ Ø®ÙˆØ¯Ú©Ø§Ø±</button>
                    <button onclick="runMultipleGames()">ğŸ“Š Ø§Ø¬Ø±Ø§ÛŒ 100 Ø¨Ø§Ø²ÛŒ</button>
                </div>

                <div class="control-group">
                    <h3>âš™ï¸ ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ù‡ÙˆØ´ Ù…ØµÙ†ÙˆØ¹ÛŒ</h3>
                    <label>
                        <input type="checkbox" id="alphaBeta" checked onchange="updateAlgorithm()">
                        Alpha-Beta Pruning ÙØ¹Ø§Ù„
                    </label>
                    <div style="margin-top: 10px;">
                        <label>Ø³Ø·Ø­ Ø³Ø®ØªÛŒ:</label>
                        <select id="difficulty" onchange="updateDifficulty()">
                            <option value="easy">Ø¢Ø³Ø§Ù† (Ø¹Ù…Ù‚ 3)</option>
                            <option value="medium">Ù…ØªÙˆØ³Ø· (Ø¹Ù…Ù‚ 6)</option>
                            <option value="hard" selected>Ø³Ø®Øª (Ø¹Ù…Ù‚ 9)</option>
                        </select>
                    </div>
                </div>
            </div>
        </div>

        <div class="stats">
            <h2>ğŸ“ˆ Ø¢Ù…Ø§Ø± Ùˆ ØªØ­Ù„ÛŒÙ„ Ø¨Ø§Ø²ÛŒ</h2>
            <div class="stats-grid">
                <div class="stat-item">
                    <div class="stat-number" id="totalGames">0</div>
                    <div>Ú©Ù„ Ø¨Ø§Ø²ÛŒâ€ŒÙ‡Ø§</div>
                </div>
                <div class="stat-item">
                    <div class="stat-number" id="playerWins">0</div>
                    <div>Ø¨Ø±Ø¯ Ø¨Ø§Ø²ÛŒÚ©Ù†</div>
                </div>
                <div class="stat-item">
                    <div class="stat-number" id="aiWins">0</div>
                    <div>Ø¨Ø±Ø¯ Ù‡ÙˆØ´ Ù…ØµÙ†ÙˆØ¹ÛŒ</div>
                </div>
                <div class="stat-item">
                    <div class="stat-number" id="draws">0</div>
                    <div>Ù…Ø³Ø§ÙˆÛŒ</div>
                </div>
            </div>

            <div style="margin-top: 20px;">
                <h3>ğŸ“Š Ø¯Ø±ØµØ¯ Ø¨Ø±Ø¯ Ùˆ Ø¨Ø§Ø®Øª</h3>
                <div>
                    Ø¨Ø±Ø¯ Ø¨Ø§Ø²ÛŒÚ©Ù†: <span id="playerWinRate">0%</span>
                    <div class="progress-bar">
                        <div class="progress-fill win-rate" id="playerWinBar" style="width: 0%"></div>
                    </div>
                </div>
                <div>
                    Ø¨Ø±Ø¯ Ù‡ÙˆØ´ Ù…ØµÙ†ÙˆØ¹ÛŒ: <span id="aiWinRate">0%</span>
                    <div class="progress-bar">
                        <div class="progress-fill lose-rate" id="aiWinBar" style="width: 0%"></div>
                    </div>
                </div>
                <div>
                    Ù…Ø³Ø§ÙˆÛŒ: <span id="drawRate">0%</span>
                    <div class="progress-bar">
                        <div class="progress-fill draw-rate" id="drawBar" style="width: 0%"></div>
                    </div>
                </div>
            </div>
        </div>

        <div class="analysis">
            <h2>ğŸ” ØªØ­Ù„ÛŒÙ„ Ø§Ù„Ú¯ÙˆØ±ÛŒØªÙ…</h2>
            <div class="algorithm-comparison">
                <div class="algorithm-stats">
                    <h3>Min-Max Ù…Ø¹Ù…ÙˆÙ„ÛŒ</h3>
                    <div>Ù…ÛŒØ§Ù†Ú¯ÛŒÙ† Ø²Ù…Ø§Ù†: <span id="minmaxTime">0</span> Ù…ÛŒÙ„ÛŒâ€ŒØ«Ø§Ù†ÛŒÙ‡</div>
                    <div>Ú¯Ø±Ù‡â€ŒÙ‡Ø§ÛŒ Ø¨Ø±Ø±Ø³ÛŒ Ø´Ø¯Ù‡: <span id="minmaxNodes">0</span></div>
                </div>
                <div class="algorithm-stats">
                    <h3>Alpha-Beta Pruning</h3>
                    <div>Ù…ÛŒØ§Ù†Ú¯ÛŒÙ† Ø²Ù…Ø§Ù†: <span id="alphabetaTime">0</span> Ù…ÛŒÙ„ÛŒâ€ŒØ«Ø§Ù†ÛŒÙ‡</div>
                    <div>Ú¯Ø±Ù‡â€ŒÙ‡Ø§ÛŒ Ø¨Ø±Ø±Ø³ÛŒ Ø´Ø¯Ù‡: <span id="alphabetaNodes">0</span></div>
                    <div>Ø¨Ù‡Ø¨ÙˆØ¯ Ø³Ø±Ø¹Øª: <span id="speedImprovement">0%</span></div>
                </div>
            </div>
            <div id="algorithmAnalysis" style="margin-top: 15px;"></div>
        </div>

        <div class="game-log">
            <h3>ğŸ“ Ú¯Ø²Ø§Ø±Ø´ Ø­Ø±Ú©Ø§Øª</h3>
            <div id="gameLog"></div>
        </div>
    </div>

    <script>
        class TicTacToe {
            constructor() {
                this.board = Array(9).fill('');
                this.currentPlayer = 'X';
                this.gameOver = false;
                this.useAlphaBeta = true;
                this.maxDepth = 9;
                this.stats = {
                    totalGames: 0,
                    playerWins: 0,
                    aiWins: 0,
                    draws: 0
                };
                this.algorithmStats = {
                    minmax: { totalTime: 0, totalNodes: 0, games: 0 },
                    alphabeta: { totalTime: 0, totalNodes: 0, games: 0 }
                };
                this.gameLog = [];
                this.initializeBoard();
            }

            initializeBoard() {
                const cells = document.querySelectorAll('.cell');
                cells.forEach((cell, index) => {
                    cell.addEventListener('click', () => this.makeMove(index));
                });
            }

            makeMove(index) {
                if (this.board[index] !== '' || this.gameOver) return;

                this.board[index] = 'X';
                this.updateBoard();
                this.logMove('Ø¨Ø§Ø²ÛŒÚ©Ù†', index, 'X');

                if (this.checkWinner()) {
                    this.endGame('Ø´Ù…Ø§ Ø¨Ø±Ù†Ø¯Ù‡ Ø´Ø¯ÛŒØ¯! ğŸ‰');
                    this.stats.playerWins++;
                    return;
                }

                if (this.isBoardFull()) {
                    this.endGame('Ø¨Ø§Ø²ÛŒ Ù…Ø³Ø§ÙˆÛŒ! ğŸ¤');
                    this.stats.draws++;
                    return;
                }

                this.currentPlayer = 'O';
                this.updateStatus('Ù†ÙˆØ¨Øª Ù‡ÙˆØ´ Ù…ØµÙ†ÙˆØ¹ÛŒ (O)');

                setTimeout(() => {
                    this.makeAIMove();
                }, 500);
            }

            makeAIMove() {
                const startTime = performance.now();
                let nodesExplored = 0;

                const bestMove = this.useAlphaBeta ? 
                    this.findBestMoveAlphaBeta() : 
                    this.findBestMoveMinMax();

                const endTime = performance.now();
                const timeTaken = endTime - startTime;

                // Ø«Ø¨Øª Ø¢Ù…Ø§Ø± Ø§Ù„Ú¯ÙˆØ±ÛŒØªÙ…
                const algType = this.useAlphaBeta ? 'alphabeta' : 'minmax';
                this.algorithmStats[algType].totalTime += timeTaken;
                this.algorithmStats[algType].totalNodes += bestMove.nodesExplored;
                this.algorithmStats[algType].games++;

                this.board[bestMove.index] = 'O';
                this.updateBoard();
                this.logMove('Ù‡ÙˆØ´ Ù…ØµÙ†ÙˆØ¹ÛŒ', bestMove.index, 'O', timeTaken, bestMove.nodesExplored);

                if (this.checkWinner()) {
                    this.endGame('Ù‡ÙˆØ´ Ù…ØµÙ†ÙˆØ¹ÛŒ Ø¨Ø±Ù†Ø¯Ù‡ Ø´Ø¯! ğŸ¤–');
                    this.stats.aiWins++;
                    return;
                }

                if (this.isBoardFull()) {
                    this.endGame('Ø¨Ø§Ø²ÛŒ Ù…Ø³Ø§ÙˆÛŒ! ğŸ¤');
                    this.stats.draws++;
                    return;
                }

                this.currentPlayer = 'X';
                this.updateStatus('Ù†ÙˆØ¨Øª Ø´Ù…Ø§ (X)');
            }

            findBestMoveMinMax() {
                let bestScore = -Infinity;
                let bestMove = -1;
                let nodesExplored = 0;

                for (let i = 0; i < 9; i++) {
                    if (this.board[i] === '') {
                        this.board[i] = 'O';
                        const result = this.minmax(0, false, this.maxDepth);
                        const score = result.score;
                        nodesExplored += result.nodes;
                        this.board[i] = '';

                        if (score > bestScore) {
                            bestScore = score;
                            bestMove = i;
                        }
                    }
                }

                return { index: bestMove, score: bestScore, nodesExplored };
            }

            findBestMoveAlphaBeta() {
                let bestScore = -Infinity;
                let bestMove = -1;
                let nodesExplored = 0;

                for (let i = 0; i < 9; i++) {
                    if (this.board[i] === '') {
                        this.board[i] = 'O';
                        const result = this.alphabeta(0, false, -Infinity, Infinity, this.maxDepth);
                        const score = result.score;
                        nodesExplored += result.nodes;
                        this.board[i] = '';

                        if (score > bestScore) {
                            bestScore = score;
                            bestMove = i;
                        }
                    }
                }

                return { index: bestMove, score: bestScore, nodesExplored };
            }

            minmax(depth, isMaximizing, maxDepth) {
                let nodes = 1;
                const winner = this.checkWinner();

                if (winner === 'O') return { score: 10 - depth, nodes };
                if (winner === 'X') return { score: depth - 10, nodes };
                if (this.isBoardFull() || depth >= maxDepth) return { score: 0, nodes };

                if (isMaximizing) {
                    let bestScore = -Infinity;
                    for (let i = 0; i < 9; i++) {
                        if (this.board[i] === '') {
                            this.board[i] = 'O';
                            const result = this.minmax(depth + 1, false, maxDepth);
                            bestScore = Math.max(bestScore, result.score);
                            nodes += result.nodes;
                            this.board[i] = '';
                        }
                    }
                    return { score: bestScore, nodes };
                } else {
                    let bestScore = Infinity;
                    for (let i = 0; i < 9; i++) {
                        if (this.board[i] === '') {
                            this.board[i] = 'X';
                            const result = this.minmax(depth + 1, true, maxDepth);
                            bestScore = Math.min(bestScore, result.score);
                            nodes += result.nodes;
                            this.board[i] = '';
                        }
                    }
                    return { score: bestScore, nodes };
                }
            }

            alphabeta(depth, isMaximizing, alpha, beta, maxDepth) {
                let nodes = 1;
                const winner = this.checkWinner();

                if (winner === 'O') return { score: 10 - depth, nodes };
                if (winner === 'X') return { score: depth - 10, nodes };
                if (this.isBoardFull() || depth >= maxDepth) return { score: 0, nodes };

                if (isMaximizing) {
                    let bestScore = -Infinity;
                    for (let i = 0; i < 9; i++) {
                        if (this.board[i] === '') {
                            this.board[i] = 'O';
                            const result = this.alphabeta(depth + 1, false, alpha, beta, maxDepth);
                            bestScore = Math.max(bestScore, result.score);
                            nodes += result.nodes;
                            this.board[i] = '';
                            alpha = Math.max(alpha, bestScore);
                            if (beta <= alpha) break; // Alpha-Beta Pruning
                        }
                    }
                    return { score: bestScore, nodes };
                } else {
                    let bestScore = Infinity;
                    for (let i = 0; i < 9; i++) {
                        if (this.board[i] === '') {
                            this.board[i] = 'X';
                            const result = this.alphabeta(depth + 1, true, alpha, beta, maxDepth);
                            bestScore = Math.min(bestScore, result.score);
                            nodes += result.nodes;
                            this.board[i] = '';
                            beta = Math.min(beta, bestScore);
                            if (beta <= alpha) break; // Alpha-Beta Pruning
                        }
                    }
                    return { score: bestScore, nodes };
                }
            }

            checkWinner() {
                const winPatterns = [
                    [0, 1, 2], [3, 4, 5], [6, 7, 8], // Ø³Ø·Ø±Ù‡Ø§
                    [0, 3, 6], [1, 4, 7], [2, 5, 8], // Ø³ØªÙˆÙ†â€ŒÙ‡Ø§
                    [0, 4, 8], [2, 4, 6] // Ù‚Ø·Ø±Ù‡Ø§
                ];

                for (const pattern of winPatterns) {
                    const [a, b, c] = pattern;
                    if (this.board[a] && this.board[a] === this.board[b] && this.board[a] === this.board[c]) {
                        return this.board[a];
                    }
                }
                return null;
            }

            isBoardFull() {
                return this.board.every(cell => cell !== '');
            }

            updateBoard() {
                const cells = document.querySelectorAll('.cell');
                cells.forEach((cell, index) => {
                    cell.textContent = this.board[index];
                    cell.className = `cell ${this.board[index].toLowerCase()}`;
                });
            }

            updateStatus(message) {
                const status = document.getElementById('status');
                status.textContent = message;
                status.className = 'status playing';
            }

            endGame(message) {
                this.gameOver = true;
                this.stats.totalGames++;
                const status = document.getElementById('status');
                status.textContent = message;
                
                if (message.includes('Ø´Ù…Ø§')) {
                    status.className = 'status win';
                } else if (message.includes('Ù‡ÙˆØ´ Ù…ØµÙ†ÙˆØ¹ÛŒ')) {
                    status.className = 'status lose';
                } else {
                    status.className = 'status draw';
                }

                this.updateStats();
                this.updateAlgorithmAnalysis();
            }

            updateStats() {
                document.getElementById('totalGames').textContent = this.stats.totalGames;
                document.getElementById('playerWins').textContent = this.stats.playerWins;
                document.getElementById('aiWins').textContent = this.stats.aiWins;
                document.getElementById('draws').textContent = this.stats.draws;

                if (this.stats.totalGames > 0) {
                    const playerRate = (this.stats.playerWins / this.stats.totalGames * 100).toFixed(1);
                    const aiRate = (this.stats.aiWins / this.stats.totalGames * 100).toFixed(1);
                    const drawRate = (this.stats.draws / this.stats.totalGames * 100).toFixed(1);

                    document.getElementById('playerWinRate').textContent = `${playerRate}%`;
                    document.getElementById('aiWinRate').textContent = `${aiRate}%`;
                    document.getElementById('drawRate').textContent = `${drawRate}%`;

                    document.getElementById('playerWinBar').style.width = `${playerRate}%`;
                    document.getElementById('aiWinBar').style.width = `${aiRate}%`;
                    document.getElementById('drawBar').style.width = `${drawRate}%`;
                }
            }

            updateAlgorithmAnalysis() {
                const minmaxAvgTime = this.algorithmStats.minmax.games > 0 ? 
                    (this.algorithmStats.minmax.totalTime / this.algorithmStats.minmax.games).toFixed(2) : 0;
                const alphabetaAvgTime = this.algorithmStats.alphabeta.games > 0 ? 
                    (this.algorithmStats.alphabeta.totalTime / this.algorithmStats.alphabeta.games).toFixed(2) : 0;

                const minmaxAvgNodes = this.algorithmStats.minmax.games > 0 ? 
                    Math.round(this.algorithmStats.minmax.totalNodes / this.algorithmStats.minmax.games) : 0;
                const alphabetaAvgNodes = this.algorithmStats.alphabeta.games > 0 ? 
                    Math.round(this.algorithmStats.alphabeta.totalNodes / this.algorithmStats.alphabeta.games) : 0;

                document.getElementById('minmaxTime').textContent = minmaxAvgTime;
                document.getElementById('alphabetaTime').textContent = alphabetaAvgTime;
                document.getElementById('minmaxNodes').textContent = minmaxAvgNodes;
                document.getElementById('alphabetaNodes').textContent = alphabetaAvgNodes;

                if (this.algorithmStats.minmax.games > 0 && this.algorithmStats.alphabeta.games > 0) {
                    const speedImprovement = ((minmaxAvgTime - alphabetaAvgTime) / minmaxAvgTime * 100).toFixed(1);
                    document.getElementById('speedImprovement').textContent = `${speedImprovement}%`;
                    
                    const nodeReduction = ((minmaxAvgNodes - alphabetaAvgNodes) / minmaxAvgNodes * 100).toFixed(1);
                    
                    document.getElementById('algorithmAnalysis').innerHTML = `
                        <strong>ØªØ­Ù„ÛŒÙ„ Ù†ØªØ§ÛŒØ¬:</strong><br>
                        Alpha-Beta Pruning Ø¯Ø± Ù…Ù‚Ø§ÛŒØ³Ù‡ Ø¨Ø§ Min-Max Ù…Ø¹Ù…ÙˆÙ„ÛŒ:<br>
                        â€¢ Ú©Ø§Ù‡Ø´ ${nodeReduction}% Ø¯Ø± ØªØ¹Ø¯Ø§Ø¯ Ú¯Ø±Ù‡â€ŒÙ‡Ø§ÛŒ Ø¨Ø±Ø±Ø³ÛŒ Ø´Ø¯Ù‡<br>
                        â€¢ Ø¨Ù‡Ø¨ÙˆØ¯ ${speedImprovement}% Ø¯Ø± Ø³Ø±Ø¹Øª Ù…Ø­Ø§Ø³Ø¨Ø§Øª<br>
                        â€¢ Ù…ÛŒØ§Ù†Ú¯ÛŒÙ† ${alphabetaAvgNodes} Ú¯Ø±Ù‡ Ø¯Ø± Ù…Ù‚Ø§Ø¨Ù„ ${minmaxAvgNodes} Ú¯Ø±Ù‡
                    `;
                }
            }

            logMove(player, position, symbol, time = null, nodes = null) {
                const logEntry = document.createElement('div');
                logEntry.className = 'log-entry';
                let logText = `${player}: Ù…ÙˆÙ‚Ø¹ÛŒØª ${position} (${symbol})`;
                if (time !== null) {
                    logText += ` - Ø²Ù…Ø§Ù†: ${time.toFixed(2)}msØŒ Ú¯Ø±Ù‡â€ŒÙ‡Ø§: ${nodes}`;
                }
                logEntry.textContent = logText;
                
                const gameLog = document.getElementById('gameLog');
                gameLog.appendChild(logEntry);
                gameLog.scrollTop = gameLog.scrollHeight;
            }

            reset() {
                this.board = Array(9).fill('');
                this.currentPlayer = 'X';
                this.gameOver = false;
                this.updateBoard();
                this.updateStatus('Ù†ÙˆØ¨Øª Ø´Ù…Ø§ (X)');
                document.getElementById('gameLog').innerHTML = '';
            }

            async playAutoGame() {
                this.reset();
                
                while (!this.gameOver) {
                    if (this.currentPlayer === 'X') {
                        // Ø­Ø±Ú©Øª ØªØµØ§Ø¯ÙÛŒ Ø¨Ø±Ø§ÛŒ Ø¨Ø§Ø²ÛŒÚ©Ù†
                        const emptyCells = [];
                        for (let i = 0; i < 9; i++) {
                            if (this.board[i] === '') emptyCells.push(i);
                        }
                        const randomMove = emptyCells[Math.floor(Math.random() * emptyCells.length)];
                        this.board[randomMove] = 'X';
                        this.logMove('Ø¨Ø§Ø²ÛŒÚ©Ù† (Ø®ÙˆØ¯Ú©Ø§Ø±)', randomMove, 'X');
                        
                        if (this.checkWinner()) {
                            this.endGame('Ø¨Ø§Ø²ÛŒÚ©Ù† Ø¨Ø±Ù†Ø¯Ù‡ Ø´Ø¯! ğŸ‰');
                            this.stats.playerWins++;
                            break;
                        }
                        
                        if (this.isBoardFull()) {
                            this.endGame('Ø¨Ø§Ø²ÛŒ Ù…Ø³Ø§ÙˆÛŒ! ğŸ¤');
                            this.stats.draws++;
                            break;
                        }
                        
                        this.currentPlayer = 'O';
                    } else {
                        this.makeAIMove();
                        if (!this.gameOver) this.currentPlayer = 'X';
                    }
                    
                    this.updateBoard();
                    await new Promise(resolve => setTimeout(resolve, 100));
                }
            }

            async runMultipleGames(count = 100) {
                const originalAlphaBeta = this.useAlphaBeta;
                
                // Ø§Ø¬Ø±Ø§ÛŒ Ø¨Ø§Ø²ÛŒâ€ŒÙ‡Ø§ Ø¨Ø§ Alpha-Beta
                this.useAlphaBeta = true;
                for (let i = 0; i < count / 2; i++) {
                    await this.playAutoGame();
                }
                
                // Ø§Ø¬Ø±Ø§ÛŒ Ø¨Ø§Ø²ÛŒâ€ŒÙ‡Ø§ Ø¨Ø¯ÙˆÙ† Alpha-Beta
                this.useAlphaBeta = false;
                for (let i = 0; i < count / 2; i++) {
                    await this.playAutoGame();
                }
                
                this.useAlphaBeta = originalAlphaBeta;
                this.updateAlgorithmAnalysis();
                
                alert(`${count} Ø¨Ø§Ø²ÛŒ Ú©Ø§Ù…Ù„ Ø´Ø¯! Ù†ØªØ§ÛŒØ¬ Ø¯Ø± Ø¨Ø®Ø´ Ø¢Ù…Ø§Ø± Ù‚Ø§Ø¨Ù„ Ù…Ø´Ø§Ù‡Ø¯Ù‡ Ø§Ø³Øª.`);
            }
        }

        // Ù…ØªØºÛŒØ± Ø³Ø±Ø§Ø³Ø±ÛŒ Ø¨Ø§Ø²ÛŒ
        let game = new TicTacToe();

        // ØªÙˆØ§Ø¨Ø¹ Ú©Ù†ØªØ±Ù„
        function resetGame() {
            game.reset();
        }

        function playAutoGame() {
            game.playAutoGame();
        }

        function runMultipleGames() {
            game.runMultipleGames(100);
        }

        function updateAlgorithm() {
            const checkbox = document.getElementById('alphaBeta');
            game.useAlphaBeta = checkbox.checked;
        }

        function updateDifficulty() {
            const difficulty = document.getElementById('difficulty').value;
            switch (difficulty) {
                case 'easy':
                    game.maxDepth = 3;
                    break;
                case 'medium':
                    game.maxDepth = 6;
                    break;
                case 'hard':
                    game.maxDepth = 9;
                    break;
            }
        }

        // Ø±Ø§Ù‡â€ŒØ§Ù†Ø¯Ø§Ø²ÛŒ Ø§ÙˆÙ„ÛŒÙ‡
        document.addEventListener('DOMContentLoaded', function() {
            game = new TicTacToe();
        });
    </script>
</body>
</html>